"""
Script de collecte d'Ã©vÃ©nements culturels
Source: API OpenAgenda via data.gouv.fr
"""

import requests
import json
import time
from datetime import datetime
import hashlib
from typing import List, Dict, Optional

class EventCollector:
    """Collecteur d'Ã©vÃ©nements culturels"""
    
    def __init__(self):
        # URL de base pour OpenAgenda (API publique)
        self.base_url = "https://openagenda.com/agendas/77918851/events.json"
        self.events = []
        
    def generate_hash(self, data: dict) -> str:
        """GÃ©nÃ¨re un hash unique pour Ã©viter les doublons"""
        data_str = json.dumps(data, sort_keys=True)
        return hashlib.md5(data_str.encode()).hexdigest()
    
    def fetch_events(self, max_events: int = 300) -> List[Dict]:
        """
        RÃ©cupÃ¨re les Ã©vÃ©nements depuis l'API
        
        Args:
            max_events: Nombre minimum d'Ã©vÃ©nements Ã  collecter
            
        Returns:
            Liste des Ã©vÃ©nements collectÃ©s
        """
        print(f"ğŸ­ DÃ©but de la collecte d'Ã©vÃ©nements...")
        print(f"ğŸ“Š Objectif: {max_events} Ã©vÃ©nements minimum\n")
        
        collected = 0
        page = 1
        errors = 0
        
        while collected < max_events:
            try:
                print(f"ğŸ“„ Page {page}...", end=" ")
                
                # ParamÃ¨tres de pagination
                params = {
                    "size": 50,  # Nombre d'Ã©vÃ©nements par page
                    "page": page
                }
                
                # RequÃªte avec timeout
                response = requests.get(
                    self.base_url,
                    params=params,
                    timeout=10
                )
                
                # VÃ©rification du statut
                response.raise_for_status()
                
                data = response.json()
                
                # Extraction des Ã©vÃ©nements
                events = data.get("events", [])
                
                if not events:
                    print("âŒ Plus d'Ã©vÃ©nements disponibles")
                    break
                
                # Traitement de chaque Ã©vÃ©nement
                for event in events:
                    # Structure normalisÃ©e avec mÃ©tadonnÃ©es
                    event_document = {
                        "source": "openagenda",
                        "fetched_at": datetime.utcnow().isoformat() + "Z",
                        "raw_hash": self.generate_hash(event),
                        "payload": event  # DonnÃ©e brute complÃ¨te
                    }
                    
                    self.events.append(event_document)
                    collected += 1
                
                print(f"âœ… {len(events)} Ã©vÃ©nements collectÃ©s (Total: {collected})")
                
                # Respect de l'API (rate limiting)
                time.sleep(0.5)
                page += 1
                
            except requests.exceptions.Timeout:
                print(f"â±ï¸ Timeout sur la page {page}")
                errors += 1
                if errors > 3:
                    print("âŒ Trop d'erreurs, arrÃªt de la collecte")
                    break
                    
            except requests.exceptions.HTTPError as e:
                print(f"âŒ Erreur HTTP: {e}")
                break
                
            except Exception as e:
                print(f"âŒ Erreur inattendue: {e}")
                errors += 1
                if errors > 3:
                    break
        
        print(f"\nâœ¨ Collecte terminÃ©e: {collected} Ã©vÃ©nements")
        print(f"âš ï¸ Erreurs rencontrÃ©es: {errors}")
        
        return self.events
    
    def fetch_from_multiple_sources(self) -> List[Dict]:
        """
        Collecte depuis plusieurs sources pour atteindre 300+ Ã©vÃ©nements
        Alternative si une seule source ne suffit pas
        """
        print("ğŸ”„ Collecte depuis sources multiples...\n")
        
        # Source 1: OpenAgenda
        self.fetch_events(max_events=150)
        
        # Source 2: On pourrait ajouter Paris Open Data, etc.
        # self.fetch_paris_events()
        
        return self.events
    
    def save_to_json(self, filename: str = "events_raw.json"):
        """Sauvegarde les Ã©vÃ©nements dans un fichier JSON"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(self.events, f, ensure_ascii=False, indent=2)
        print(f"ğŸ’¾ DonnÃ©es sauvegardÃ©es dans {filename}")
    
    def get_summary(self) -> Dict:
        """Retourne un rÃ©sumÃ© de la collecte"""
        if not self.events:
            return {"total": 0}
        
        return {
            "total_events": len(self.events),
            "sources": list(set(e["source"] for e in self.events)),
            "date_range": {
                "first_fetch": min(e["fetched_at"] for e in self.events),
                "last_fetch": max(e["fetched_at"] for e in self.events)
            }
        }


def main():
    """Point d'entrÃ©e principal"""
    print("=" * 60)
    print("ğŸª COLLECTEUR D'Ã‰VÃ‰NEMENTS CULTURELS")
    print("=" * 60 + "\n")
    
    # Initialisation
    collector = EventCollector()
    
    # Collecte
    events = collector.fetch_events(max_events=300)
    
    # VÃ©rification
    if len(events) < 300:
        print(f"\nâš ï¸ Seulement {len(events)} Ã©vÃ©nements collectÃ©s")
        print("ğŸ’¡ Essai avec sources multiples...")
        # On pourrait ajouter d'autres sources ici
    
    # Sauvegarde
    if events:
        collector.save_to_json()
        
        # RÃ©sumÃ©
        print("\n" + "=" * 60)
        print("ğŸ“Š RÃ‰SUMÃ‰ DE LA COLLECTE")
        print("=" * 60)
        summary = collector.get_summary()
        print(f"Total: {summary['total_events']} Ã©vÃ©nements")
        print(f"Sources: {', '.join(summary['sources'])}")
    else:
        print("\nâŒ Aucun Ã©vÃ©nement collectÃ©")
    
    print("\nâœ… Script terminÃ©")


if __name__ == "__main__":
    main()